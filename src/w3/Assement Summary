See the Assessment Guide for information on how to interpret this report.

ASSESSMENT SUMMARY

Compilation:  PASSED
API:          PASSED

Findbugs:     FAILED (5 warnings)
PMD:          PASSED
Checkstyle:   FAILED (0 errors, 6 warnings)

Correctness:  27/41 tests passed
Memory:       1/1 tests passed
Timing:       10/41 tests passed

Aggregate score: 64.39%
[Compilation: 5%, API: 5%, Findbugs: 0%, PMD: 0%, Checkstyle: 0%, Correctness: 60%, Memory: 10%, Timing: 20%]

ASSESSMENT DETAILS

The following files were submitted:
----------------------------------
4.0K Jan  7 11:41 BruteCollinearPoints.java
3.6K Jan  7 11:41 FastCollinearPoints.java
4.6K Jan  7 11:41 Point.java


********************************************************************************
*  COMPILING
********************************************************************************


% javac Point.java
*-----------------------------------------------------------

% javac BruteCollinearPoints.java
*-----------------------------------------------------------

% javac FastCollinearPoints.java
*-----------------------------------------------------------


================================================================


Checking the APIs of your programs.
*-----------------------------------------------------------
Point:

BruteCollinearPoints:

FastCollinearPoints:

================================================================


********************************************************************************
*  CHECKING STYLE AND COMMON BUG PATTERNS
********************************************************************************


% findbugs *.class
*-----------------------------------------------------------
L P UPM_UNCALLED_PRIVATE_METHOD UPM: The private method 'check()' is never called.  At BruteCollinearPoints.java:[lines 86-87]
L P UPM_UNCALLED_PRIVATE_METHOD UPM: The private method 'permutation()' is never called.  At BruteCollinearPoints.java:[lines 90-95]
L D FE_FLOATING_POINT_EQUALITY FE: Tests for exact floating-point equality. Because floating-point calculations may involve rounding, the calculated values may be imprecise.  At BruteCollinearPoints.java:[line 57]
L D FE_FLOATING_POINT_EQUALITY FE: Tests for exact floating-point equality. Because floating-point calculations may involve rounding, the calculated values may be imprecise.  At FastCollinearPoints.java:[line 35]
M P UUF_UNUSED_FIELD UuF: The instance (or static) variable 'segments' is never used. Consider removing it from the class.  In FastCollinearPoints.java
Warnings generated: 5


================================================================


% pmd .
*-----------------------------------------------------------
BruteCollinearPoints.java:14: The private instance (or static) variable 'segments' can be made 'final'; it is initialized only in the declaration or constructor. [ImmutableField]
BruteCollinearPoints.java:15: Can you replace the instance (or static) variable 'sloops' with a local variable? [SingularField]
BruteCollinearPoints.java:15: The private instance (or static) variable 'sloops' can be made 'final'; it is initialized only in the declaration or constructor. [ImmutableField]
BruteCollinearPoints.java:16: Can you replace the instance (or static) variable 'p' with a local variable? [SingularField]
BruteCollinearPoints.java:16: The private instance (or static) variable 'p' can be made 'final'; it is initialized only in the declaration or constructor. [ImmutableField]
BruteCollinearPoints.java:85: Avoid unused private methods, such as 'check(Point,Point)'. [UnusedPrivateMethod]
BruteCollinearPoints.java:89: Avoid unused private methods, such as 'permutation(Point,Point)'. [UnusedPrivateMethod]
FastCollinearPoints.java:13: Can you replace the instance (or static) variable 'p' with a local variable? [SingularField]
FastCollinearPoints.java:13: The private instance (or static) variable 'p' can be made 'final'; it is initialized only in the declaration or constructor. [ImmutableField]
FastCollinearPoints.java:14: Avoid unused private instance (or static) variables, such as 'segments'. [UnusedPrivateField]
FastCollinearPoints.java:15: The private instance (or static) variable 'lines' can be made 'final'; it is initialized only in the declaration or constructor. [ImmutableField]
Point.java:132: The private instance (or static) variable 'invokePoint' can be made 'final'; it is initialized only in the declaration or constructor. [ImmutableField]
PMD ends with 12 warnings.


================================================================


% checkstyle *.java
*-----------------------------------------------------------
[WARN] BruteCollinearPoints.java:94:14: Conditional logic can be removed. [SimplifyBooleanReturn]
[WARN] FastCollinearPoints.java:22:11: '//' or '/*' is not followed by whitespace. [WhitespaceAfter]
[WARN] FastCollinearPoints.java:62:23: The local (or parameter) variable 'segments' has the same name as an instance variable. Use a different name. [HiddenField]
[WARN] FastCollinearPoints.java:72:33: The local (or parameter) variable 'p' has the same name as an instance variable. Use a different name. [HiddenField]
[WARN] FastCollinearPoints.java:85:14: Conditional logic can be removed. [SimplifyBooleanReturn]
[WARN] Point.java:125:28: ',' is not followed by whitespace. [WhitespaceAfter]
Checkstyle ends with 0 errors and 6 warnings.

% custom checkstyle checks for Point.java
*-----------------------------------------------------------

% custom checkstyle checks for BruteCollinearPoints.java
*-----------------------------------------------------------

% custom checkstyle checks for FastCollinearPoints.java
*-----------------------------------------------------------


================================================================


********************************************************************************
*  TESTING CORRECTNESS
********************************************************************************

Testing correctness of Point
*-----------------------------------------------------------
Running 3 total tests.

Test 1: p.slopeTo(q)
  * positive infinite slope, where p and q have coordinates in [0, 500)
  * positive infinite slope, where p and q have coordinates in [0, 32768)
  * negative infinite slope, where p and q have coordinates in [0, 500)
  * negative infinite slope, where p and q have coordinates in [0, 32768)
  * positive zero     slope, where p and q have coordinates in [0, 500)
  * positive zero     slope, where p and q have coordinates in [0, 32768)
  * symmetric for random points p and q with coordinates in [0, 500)
  * symmetric for random points p and q with coordinates in [0, 32768)
  * transitive for random points p, q, and r with coordinates in [0, 500)
  * transitive for random points p, q, and r with coordinates in [0, 32768)
  * slopeTo(), where p and q have coordinates in [0, 500)
  * slopeTo(), where p and q have coordinates in [0, 32768)
  * slopeTo(), where p and q have coordinates in [0, 10)
  * throw a java.lang.NullPointerException if argument is null
    java.lang.IllegalArgumentException: argument to slopeTo is null

    Point.slopeTo(Point.java:60)
    TestPoint.nullSlopeTo(TestPoint.java:486)
    TestPoint.test1(TestPoint.java:865)
    TestPoint.main(TestPoint.java:913)

==> FAILED

Test 2: p.compareTo(q)
  * reflexive, where p and q have coordinates in [0, 500)
  * reflexive, where p and q have coordinates in [0, 32768)
  * antisymmetric, where p and q have coordinates in [0, 500)
  * antisymmetric, where p and q have coordinates in [0, 32768)
  * transitive, where p, q, and r have coordinates in [0, 500)
  * transitive, where p, q, and r have coordinates in [0, 32768)
  * sign of compareTo(), where p and q have coordinates in [0, 500)
  * sign of compareTo(), where p and q have coordinates in [0, 32768)
  * sign of compareTo(), where p and q have coordinates in [0, 10)
  * throw java.lang.NullPointerException exception if argument is null
    java.lang.IllegalArgumentException: argument to compareTo is null

    Point.compareTo(Point.java:80)
    TestPoint.nullCompareTo(TestPoint.java:634)
    TestPoint.test2(TestPoint.java:885)
    TestPoint.main(TestPoint.java:914)

==> FAILED

Test 3: p.slopeOrder().compare(q, r)
  * reflexive, where p and q have coordinates in [0, 500)
  * reflexive, where p and q have coordinates in [0, 32768)
  * antisymmetric, where p, q, and r have coordinates in [0, 500)
  * antisymmetric, where p, q, and r have coordinates in [0, 32768)
  * transitive, where p, q, r, and s have coordinates in [0, 500)
  * transitive, where p, q, r, and s have coordinates in [0, 32768)
  * sign of compare(), where p, q, and r have coordinates in [0, 500)
  * sign of compare(), where p, q, and r have coordinates in [0, 32768)
  * sign of compare(), where p, q, and r have coordinates in [0, 10)
  * throw java.lang.NullPointerException if either argument is null
    java.lang.IllegalArgumentException: argument to slopeTo is null

    Point.slopeTo(Point.java:60)
    Point$SlopeComparator.compare(Point.java:140)
    Point$SlopeComparator.compare(Point.java:131)
    TestPoint.nullCompare(TestPoint.java:768)
    TestPoint.test3(TestPoint.java:902)
    TestPoint.main(TestPoint.java:915)

==> FAILED


Total: 0/3 tests passed!


================================================================
********************************************************************************
*  TESTING CORRECTNESS (substituting reference Point and LineSegment)
********************************************************************************

Testing correctness of BruteCollinearPoints
*-----------------------------------------------------------
Running 17 total tests.

The inputs satisfy the following conditions:
  - no duplicate points
  - no 5 (or more) points are collinear
  - all x- and y-coordinates between 0 and 32,767

Test 1: points from a file
  * filename = input8.txt
  * filename = equidistant.txt
  * filename = input40.txt
    - number of entries in student   solution: 3
    - number of entries in reference solution: 4
    - 1 missing entry in student solution: '(2000, 29000) -> (4000, 29000) -> (22000, 29000) -> (28000, 29000)'

  * filename = input48.txt
    - number of entries in student   solution: 5
    - number of entries in reference solution: 6
    - 1 missing entry in student solution: '(1000, 26000) -> (9000, 26000) -> (11000, 26000) -> (18000, 26000)'

==> FAILED

Test 2a: points from a file with horizontal line segments
  * filename = horizontal5.txt
    - number of entries in student   solution: 1
    - number of entries in reference solution: 5
    - 4 missing entries in student solution, including: '(2682, 14118) -> (5067, 14118) -> (7453, 14118) -> (7821, 14118)'

  * filename = horizontal25.txt
    - number of entries in student   solution: 1
    - number of entries in reference solution: 25
    - 24 missing entries in student solution, including: '(8784, 20913) -> (9880, 20913) -> (16352, 20913) -> (19666, 20913)'

==> FAILED

Test 2b: random horizontal line segments
  *  1 random horizontal line segment
  *  5 random horizontal line segments
    - number of entries in student   solution: 1
    - number of entries in reference solution: 5
    - 4 missing entries in student solution, including: '(1334, 20893) -> (8117, 20893) -> (11353, 20893) -> (17329, 20893)'

    - failed on trial 1 of 250
     20
      6856 15360
     18360  6646
     11496 15360
     20574 15360
     19898 15360
     16108 13915
      1334 20893
     17329 20893
     20317  7237
     11353 20893
     14744 13915
      8446  6646
      1095  7237
      6150 13915
     16068  7237
      8117 20893
     15529 13915
      4110  7237
     19487  6646
     17510  6646

  * 10 random horizontal line segments
    - number of entries in student   solution: 1
    - number of entries in reference solution: 10
    - 9 missing entries in student solution, including: '(6627, 20440) -> (8320, 20440) -> (10484, 20440) -> (18954, 20440)'

    - failed on trial 1 of 50

  * 15 random horizontal line segments
    - number of entries in student   solution: 1
    - number of entries in reference solution: 15
    - 14 missing entries in student solution, including: '(1144, 20098) -> (6571, 20098) -> (9496, 20098) -> (17580, 20098)'

    - failed on trial 1 of 5

==> FAILED

Test 3a: points from a file with vertical line segments
  * filename = vertical5.txt
    - number of entries in student   solution: 1
    - number of entries in reference solution: 5
    - 4 missing entries in student solution, including: '(14407, 10367) -> (14407, 17188) -> (14407, 17831) -> (14407, 19953)'

  * filename = vertical25.txt
    - number of entries in student   solution: 1
    - number of entries in reference solution: 25
    - 24 missing entries in student solution, including: '(19953, 10489) -> (19953, 10688) -> (19953, 19299) -> (19953, 20439)'

==> FAILED

Test 3b: random vertical line segments
  *  1 random vertical line segment
  *  5 random vertical line segments
    - number of entries in student   solution: 1
    - number of entries in reference solution: 5
    - 4 missing entries in student solution, including: '(6275, 13184) -> (6275, 15504) -> (6275, 17404) -> (6275, 18501)'

    - failed on trial 1 of 250
     20
      6631  2944
     16229  7516
     10382  3170
      6470  3877
      6470  3118
      6631  7398
      6275 13184
     16229  3989
      6470  1956
      6631  6627
      6631  2828
     16229 19346
     10382 20433
     10382  8710
     16229  7330
      6275 15504
      6275 18501
      6470 20595
     10382 17655
      6275 17404

  * 10 random vertical line segments
    - number of entries in student   solution: 1
    - number of entries in reference solution: 10
    - 9 missing entries in student solution, including: '(20691, 12314) -> (20691, 15332) -> (20691, 15681) -> (20691, 20338)'

    - failed on trial 1 of 50

  * 15 random vertical line segments
    - number of entries in student   solution: 1
    - number of entries in reference solution: 15
    - 14 missing entries in student solution, including: '(14424, 12616) -> (14424, 16620) -> (14424, 17058) -> (14424, 20175)'

    - failed on trial 1 of 5

==> FAILED

Test 4a: points from a file with no line segments
  * filename = random23.txt
  * filename = random38.txt
==> passed

Test 4b: random points with no line segments
  *  5 random points
  * 10 random points
  * 20 random points
  * 50 random points
==> passed

Test 5: points from a file with fewer than 4 points
  * filename = input1.txt
  * filename = input2.txt
  * filename = input3.txt
==> passed

Test 6: check for dependence on either compareTo() or compare()
        returning { -1, +1, 0 } instead of { negative integer,
        positive integer, zero }
  * filename = equidistant.txt
  * filename = input40.txt
    - number of entries in student   solution: 3
    - number of entries in reference solution: 4
    - 1 missing entry in student solution: '(2000, 29000) -> (4000, 29000) -> (22000, 29000) -> (28000, 29000)'

  * filename = input48.txt
    - number of entries in student   solution: 5
    - number of entries in reference solution: 6
    - 1 missing entry in student solution: '(1000, 26000) -> (9000, 26000) -> (11000, 26000) -> (18000, 26000)'

==> FAILED

Test 7: check for fragile dependence on return value of toString()
  * filename = equidistant.txt
  * filename = input40.txt
    - number of entries in student   solution: 3
    - number of entries in reference solution: 4
    - 1 missing entry in student solution: '(2000, 29000) -> (4000, 29000) -> (22000, 29000) -> (28000, 29000)'

  * filename = input48.txt
    - number of entries in student   solution: 5
    - number of entries in reference solution: 6
    - 1 missing entry in student solution: '(1000, 26000) -> (9000, 26000) -> (11000, 26000) -> (18000, 26000)'


It is bad style to write code that depends on the particular format of
the output from the toString() method, especially if your reason for
doing so is to circumvent the public API (which intentionally does not
provide access to the x- and y-coordinates).

==> FAILED

Test 8: random line segments, none vertical or horizontal
  *  1 random line segment
  *  5 random line segments
  * 10 random line segments
  * 15 random line segments
==> passed

Test 9: random line segments
  *  1 random line segment
  *  5 random line segments
    - number of entries in student   solution: 4
    - number of entries in reference solution: 5
    - 1 missing entry in student solution: '(7848, 12892) -> (8360, 12892) -> (11496, 12892) -> (11688, 12892)'

    - failed on trial 39 of 250
     20
      4671  7865
     11542   864
     12810  6682
      6315  7190
      5875  7865
     11496 12892
      6687  7865
     12554  2844
     11220   234
     11688 12892
      4867  7865
      8360 12892
      7827  9262
     11385  2920
      7557  8892
     14900  7434
      7848 12892
     12660  6286
     12835  6748
      7233  8448

  * 10 random line segments
    - number of entries in student   solution: 8
    - number of entries in reference solution: 10
    - 2 missing entries in student solution, including: '(1514, 14977) -> (2229, 14977) -> (3384, 14977) -> (3769, 14977)'

    - failed on trial 27 of 100

  * 15 random line segments
    - number of entries in student   solution: 14
    - number of entries in reference solution: 15
    - 1 missing entry in student solution: '(14879, 12181) -> (14879, 12289) -> (14879, 12541) -> (14879, 12595)'

    - failed on trial 4 of 50

==> FAILED

Test 10: check that data type is immutable by testing whether each method
         returns the same value, regardless of any intervening operations
  * input8.txt
  * equidistant.txt
==> passed

Test 11: check that data type does not mutate the constructor argument
  * input8.txt
  * equidistant.txt
==> passed

Test 12: numberOfSegments() is consistent with segments()
  * filename = input8.txt
  * filename = equidistant.txt
  * filename = input40.txt
  * filename = input48.txt
  * filename = horizontal5.txt
  * filename = vertical5.txt
  * filename = random23.txt
==> passed

Test 13: throws an exception if either the constructor argument is null
         or any entry in array is null
  * argument is null
  * Point[] of length 10, number of null entries = 1
  * Point[] of length 10, number of null entries = 10
  * Point[] of length 4, number of null entries = 1
  * Point[] of length 3, number of null entries = 1
  * Point[] of length 2, number of null entries = 1
  * Point[] of length 1, number of null entries = 1
==> passed

Test 14: check that the constructor throws an exception if duplicate points
  * 50 points
    - failed on trial 1 of 5
    - constructor fails to throw a java.lang.IllegalArgumentException when passed duplicate points

  * 25 points
    - failed on trial 1 of 10
    - constructor fails to throw a java.lang.IllegalArgumentException when passed duplicate points

  * 5 points
    - failed on trial 1 of 100
    - constructor fails to throw a java.lang.IllegalArgumentException when passed duplicate points
     5
     11172 16467
     27910  2219
     30413 11765
     31773 13786
     30413 11765

  * 4 points
    - failed on trial 1 of 100
    - constructor fails to throw a java.lang.IllegalArgumentException when passed duplicate points
     4
      4486 22963
     28853 24617
      4486 22963
     24134  1252

  * 3 points
    - failed on trial 1 of 100
    - constructor fails to throw a java.lang.IllegalArgumentException when passed duplicate points
     3
      1511 13542
     21228  3937
      1511 13542

  * 2 points
    - failed on trial 1 of 100
    - constructor fails to throw a java.lang.IllegalArgumentException when passed duplicate points
     2
     10953   167
     10953   167

==> FAILED


Total: 8/17 tests passed!


================================================================
Testing correctness of FastCollinearPoints
*-----------------------------------------------------------
Running 21 total tests.

The inputs satisfy the following conditions:
  - no duplicate points
  - all x- and y-coordinates between 0 and 32,767

Test 1: points from a file
  * filename = input8.txt
  * filename = equidistant.txt
  * filename = input40.txt
  * filename = input48.txt
  * filename = input299.txt
==> passed

Test 2a: points from a file with horizontal line segments
  * filename = horizontal5.txt
  * filename = horizontal25.txt
  * filename = horizontal50.txt
  * filename = horizontal75.txt
  * filename = horizontal100.txt
==> passed

Test 2b: random horizontal line segments
  *  1 random horizontal line segment
  *  5 random horizontal line segments
  * 10 random horizontal line segments
  * 15 random horizontal line segments
==> passed

Test 3a: points from a file with vertical line segments
  * filename = vertical5.txt
  * filename = vertical25.txt
  * filename = vertical50.txt
  * filename = vertical75.txt
  * filename = vertical100.txt
==> passed

Test 3b: random vertical line segments
  *  1 random vertical line segment
  *  5 random vertical line segments
  * 10 random vertical line segments
  * 15 random vertical line segments
==> passed

Test 4a: points from a file with no line segments
  * filename = random23.txt
  * filename = random38.txt
  * filename = random91.txt
  * filename = random152.txt
==> passed

Test 4b: random points with no line segments
  *  5 random points
  * 10 random points
  * 20 random points
  * 50 random points
==> passed

Test 5a: points from a file with 5 or more on some line segments
  * filename = input9.txt
  * filename = input10.txt
  * filename = input20.txt
  * filename = input50.txt
  * filename = input80.txt
  * filename = input300.txt
  * filename = inarow.txt
==> passed

Test 5b: points from a file with 5 or more on some line segments
  * filename = kw1260.txt
  * filename = rs1423.txt
==> passed

Test 6: points from a file with fewer than 4 points
  * filename = input1.txt
    java.lang.ArrayIndexOutOfBoundsException: 1

    FastCollinearPoints.<init>(FastCollinearPoints.java:30)
    TestFastCollinearPoints.testSegments(TestFastCollinearPoints.java:107)
    TestFastCollinearPoints.file(TestFastCollinearPoints.java:151)
    TestFastCollinearPoints.test6(TestFastCollinearPoints.java:314)
    TestFastCollinearPoints.main(TestFastCollinearPoints.java:805)

  * filename = input2.txt
  * filename = input3.txt
==> FAILED

Test 7: check for dependence on either compareTo() or compare()
        returning { -1, +1, 0 } instead of { negative integer,
        positive integer, zero }
  * filename = equidistant.txt
  * filename = input40.txt
  * filename = input48.txt
  * filename = input299.txt
==> passed

Test 8: check for fragile dependence on return value of toString()
  * filename = equidistant.txt
  * filename = input40.txt
  * filename = input48.txt
==> passed

Test 9: random line segments, none vertical or horizontal
  *  1 random line segment
  *  5 random line segments
  * 25 random line segments
  * 50 random line segments
  * 100 random line segments
==> passed

Test 10: random line segments
  *  1 random line segment
  *  5 random line segments
  * 25 random line segments
  * 50 random line segments
  * 100 random line segments
==> passed

Test 11: random distinct points in a given range
  * 5 random points in a 10-by-10 grid
  * 10 random points in a 10-by-10 grid
  * 50 random points in a 10-by-10 grid
  * 90 random points in a 10-by-10 grid
  * 200 random points in a 50-by-50 grid
==> passed

Test 12: m*n points on an m-by-n grid
  * 3-by-3 grid
  * 4-by-4 grid
  * 5-by-5 grid
  * 10-by-10 grid
  * 20-by-20 grid
  * 5-by-4 grid
  * 6-by-4 grid
  * 10-by-4 grid
  * 15-by-4 grid
  * 25-by-4 grid
==> passed

Test 13: check that data type is immutable by testing whether each method
         returns the same value, regardless of any intervening operations
  * input8.txt
    - failed after 6 operations involving FastCollinearPoints
    - first and last call to segments() returned different arrays
    - sequence of operations was:
          FastCollinearPoints collinear = new FastCollinearPoints(points);
          collinear.numberOfSegments() -> 2
          collinear.segments()
          mutate points[] array that was passed to constructor
          mutate points[] array that was passed to constructor
          collinear.segments()
    - failed on trial 1 of 100

  * equidistant.txt
    - failed after 5 operations involving FastCollinearPoints
    - first and last call to segments() returned different arrays
    - sequence of operations was:
          FastCollinearPoints collinear = new FastCollinearPoints(points);
          collinear.segments()
          mutate array returned by last call to segments()
          mutate points[] array that was passed to constructor
          collinear.segments()
    - failed on trial 1 of 100

==> FAILED

Test 14: check that data type does not mutate the constructor argument
  * input8.txt
  * equidistant.txt
==> passed

Test 15: numberOfSegments() is consistent with segments()
  * filename = input8.txt
  * filename = equidistant.txt
  * filename = input40.txt
  * filename = input48.txt
  * filename = horizontal5.txt
  * filename = vertical5.txt
  * filename = random23.txt
==> passed

Test 16: throws an exception if either constructor argument is null
         or any entry in array is null
  * argument is null
  * Point[] of length 10, number of null entries = 1
  * Point[] of length 10, number of null entries = 10
  * Point[] of length 4, number of null entries = 1
  * Point[] of length 3, number of null entries = 1
  * Point[] of length 2, number of null entries = 1
  * Point[] of length 1, number of null entries = 1
==> passed

Test 17: check that the constructor throws an exception if duplicate points
  * 50 points
  * 25 points
  * 5 points
  * 4 points
  * 3 points
  * 2 points
==> passed


Total: 19/21 tests passed!


================================================================
********************************************************************************
*  MEMORY
********************************************************************************

Analyzing memory of Point
*-----------------------------------------------------------
Running 1 total tests.

The maximum amount of memory per Point object is 32 bytes.

Student memory = 24 bytes (passed)

Total: 1/1 tests passed!

================================================================



********************************************************************************
*  TIMING
********************************************************************************

Timing BruteCollinearPoints
*-----------------------------------------------------------
Running 10 total tests.

Test 1a-1e: Find collinear points among n random distinct points


                                                      slopeTo()
             n    time     slopeTo()   compare()  + 2*compare()        compareTo()
-----------------------------------------------------------------------------------------------
=> passed    16   0.01         680           0            680                   48
=> passed    32   0.00        5456           0           5456                  123
=> passed    64   0.00       43680           0          43680                  302
=> passed   128   0.01      349504           0         349504                  740
=> passed   256   0.06     2796160           0        2796160                 1731
==> 5/5 tests passed

Test 2a-2e: Find collinear points among n/4 arbitrary line segments


                                                      slopeTo()
             n    time     slopeTo()   compare()  + 2*compare()        compareTo()
-----------------------------------------------------------------------------------------------
=> passed    16   0.00         680           0            680                   46
=> passed    32   0.00        5456           0           5456                  126
=> passed    64   0.00       43680           0          43680                  308
=> passed   128   0.01      349504           0         349504                  734
=> passed   256   0.03     2796160           0        2796160                 1738
==> 5/5 tests passed

Total: 10/10 tests passed!


================================================================



Timing FastCollinearPoints
*-----------------------------------------------------------
Running 31 total tests.

Test 1a-1g: Find collinear points among n random distinct points


                                                      slopeTo()
             n    time     slopeTo()   compare()  + 2*compare()        compareTo()
-----------------------------------------------------------------------------------------------
=> passed    64   0.01        7936       18500          44936                   64
=> passed   128   0.01       32256       88437         209130                  128
=> passed   256   0.05      130048      412620         955288                  256
=> passed   512   0.15      522240     1884274        4290788                  512
=> passed  1024   0.44     2093056     8515832       19124720                 1024
=> passed  2048   0.92     8380416    37872369       84125154                 2048
==> 6/6 tests passed

lg ratio(slopeTo() + 2*compare()) = lg (84125154 / 19124720) = 2.14
=> passed

==> 7/7 tests passed

Test 2a-2g: Find collinear points among the n points on an n-by-1 grid

                                                      slopeTo()
             n    time     slopeTo()   compare()  + 2*compare()        compareTo()
-----------------------------------------------------------------------------------------------
=> passed    64   0.01        7936        4764          17464                19975
=> passed   128   0.01       32256       17796          67848                94497
=> FAILED   256   0.02      130048       68717         267482               444120   (1.1x)
=> FAILED   512   0.14      522240      269399        1061038              2031169   (1.4x)
=> FAILED  1024   0.29     2093056     1065026        4223108              9195971   (1.6x)
=> FAILED  2048   0.80     8380416     4231214       16842844             40945257   (1.9x)
=> FAILED  4096   3.00    33538048    16859163       67256374            180313567   (2.1x)
==> 2/7 tests passed

lg ratio(slopeTo() + 2*compare()) = lg (67256374 / 16842844) = 2.00
=> passed

==> 3/8 tests passed

Test 3a-3g: Find collinear points among the n points on an n/4-by-4 grid

                                                      slopeTo()
             n    time     slopeTo()   compare()  + 2*compare()        compareTo()
-----------------------------------------------------------------------------------------------
=> passed    64   0.00        7936       17570          43076                20727
=> passed   128   0.01       32256       72708         177672               259810
=> FAILED   256   0.05      130048      285693         701434              3851975   (3.1x)
=> FAILED   512   0.61      522240     1108774        2739788             60355484  (12.8x)
=> FAILED  1024   9.88     2093056     4406321       10905698            959049612  (52.0x)
=> FAILED  2048 146.92     8380416    17538524       43457464          15304236737 (210.9x)
Aborting: time limit of 10 seconds exceeded

Test 4a-4g: Find collinear points among the n points on an n/8-by-8 grid

                                                      slopeTo()
             n    time     slopeTo()   compare()  + 2*compare()        compareTo()
-----------------------------------------------------------------------------------------------
=> passed    64   0.00        7936       18616          45168                 9801
=> passed   128   0.00       32256       86711         205678                79990
=> passed   256   0.03      130048      381116         892280              1010592
=> FAILED   512   0.37      522240     1628039        3778318             15016721   (2.2x)
=> FAILED  1024   5.19     2093056     6730296       15553648            235910105   (8.9x)


WARNING: the time limit of 180 seconds was exceeded, so not all tests could be completed.


Total: 0/31 tests passed: Could not complete tests, which results in a reported score of 0.
================================================================