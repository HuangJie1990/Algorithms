See the Assessment Guide for information on how to interpret this report.

ASSESSMENT SUMMARY

Compilation:  PASSED
API:          PASSED

Findbugs:     FAILED (1 warning)
PMD:          PASSED
Checkstyle:   FAILED (0 errors, 6 warnings)

Correctness:  29/64 tests passed
Memory:       10/10 tests passed
Timing:       115/159 tests passed

Aggregate score: 61.65%
[Compilation: 5%, API: 5%, Findbugs: 0%, PMD: 0%, Checkstyle: 0%, Correctness: 60%, Memory: 10%, Timing: 20%]

ASSESSMENT DETAILS

The following files were submitted:
----------------------------------
3.1K Mar 22 03:05 BurrowsWheeler.java
1.1K Mar 22 03:05 CircularSuffixArray.java
1.5K Mar 22 03:05 MoveToFront.java


********************************************************************************
*  COMPILING
********************************************************************************


% javac CircularSuffixArray.java
*-----------------------------------------------------------

% javac BurrowsWheeler.java
*-----------------------------------------------------------

% javac MoveToFront.java
*-----------------------------------------------------------


================================================================


Checking the APIs of your programs.
*-----------------------------------------------------------
CircularSuffixArray:

BurrowsWheeler:

MoveToFront:

================================================================


********************************************************************************
*  CHECKING STYLE AND COMMON BUG PATTERNS
********************************************************************************


% findbugs *.class
*-----------------------------------------------------------
M D DLS_DEAD_LOCAL_STORE DLS: Assigns a value to the local variable 'first' but that value is never used.  At BurrowsWheeler.java:[line 39]
Warnings generated: 1


================================================================


% pmd .
*-----------------------------------------------------------
BurrowsWheeler.java:39: Avoid unused local variables, such as 'first'. [UnusedLocalVariable]
CircularSuffixArray.java:9: The private instance (or static) variable 'suffixArray' can be made 'final'; it is initialized only in the declaration or constructor. [ImmutableField]
PMD ends with 2 warnings.


================================================================


% checkstyle *.java
*-----------------------------------------------------------
[WARN] BurrowsWheeler.java:76:38: ';' is followed by whitespace. [EmptyForIteratorPad]
[WARN] CircularSuffixArray.java:27:7: '//' or '/*' is not followed by whitespace. [WhitespaceAfter]
Checkstyle ends with 0 errors and 2 warnings.

% custom checkstyle checks for CircularSuffixArray.java
*-----------------------------------------------------------

% custom checkstyle checks for BurrowsWheeler.java
*-----------------------------------------------------------
[WARN] BurrowsWheeler.java:41:9: You should not need to use the 'StringBuilder' data type in this program. [Design]
[WARN] BurrowsWheeler.java:51:20: You will probably not meet the performance requirement for 'inverseTransform()' if you call 'Arrays.sort()'. [Performance]
Checkstyle ends with 0 errors and 2 warnings.

% custom checkstyle checks for MoveToFront.java
*-----------------------------------------------------------
[WARN] MoveToFront.java:1: Use the 'equals()' method to check whether the command-line argument is '+' or '-'. [Design]
[WARN] MoveToFront.java:1:1: The constant '256' appears more than once. Define a constant variable (such as 'EXTENDED_ASCII') to hold the constant '256'. [NumericLiteralCount]
Checkstyle ends with 0 errors and 2 warnings.


================================================================


********************************************************************************
*  TESTING CORRECTNESS
********************************************************************************

Testing correctness of CircularSuffixArray
*-----------------------------------------------------------
Running 15 total tests.

Test 1: check index() and length() with random binary strings
  * length = 10
    - string = "BBBBAAAAAB"
    - mismatch in indices
    - student   index(5) = 9
    - reference index(5) = 3

    - failed on trial 1 of 1000

  * length = 100
    - string = "BBAABABABBABBBBAAABBBBABABBBABBAABAAAAAABBBABAAABAAABAAABBBB..."
    - mismatch in indices
    - student   index(12) = 95
    - reference index(12) = 38

    - failed on trial 1 of 1000

  * length = 1000
    - string = "BBAABAABABAAAAABABBBAABBABBAABABAAABBBABBABBABABABBBBABBBABA..."
    - mismatch in indices
    - student   index(0) = 999
    - reference index(0) = 382

    - failed on trial 1 of 1000

==> FAILED

Test 2: check index() and length() with random uppercase strings
  * length = 10
    - string = "YBZZPJBHNJ"
    - mismatch in indices
    - student   index(3) = 9
    - reference index(3) = 5

    - failed on trial 9 of 1000

  * length = 100
    - string = "HUPXYESDKEBISWNVIGEBBMOJCFMKQVHIJZWTJDWKGDUMADFWGTAXKVFSQAJU..."
    - mismatch in indices
    - student   index(96) = 99
    - reference index(96) = 4

    - failed on trial 1 of 1000

  * length = 1000
    - string = "WOTSDUBIMNPUTOMGWEGDFLHJWWSNFDCXTWDEGPPICPZLZQGJVABRCQMRNFYH..."
    - mismatch in indices
    - student   index(437) = 998
    - reference index(437) = 520

    - failed on trial 1 of 1000

==> FAILED

Test 3: check index() and length() with random ASCII strings
  * length = 10
    - string = hex representation: 7e 65 1c 07 4a 4c 33 47 49 47
    - mismatch in indices
    - student   index(3) = 9
    - reference index(3) = 7

    - failed on trial 15 of 1000

  * length = 100
    - string = hex representation: 62 64 0b 6e 6b 5f 7c 2b 6e 5c 15 12 72 0a 68 4b 42 6b 78 0e ...
    - mismatch in indices
    - student   index(79) = 99
    - reference index(79) = 8

    - failed on trial 2 of 1000

  * length = 1000
    - string = hex representation: 40 43 4d 36 23 76 24 16 26 4c 3e 42 6f 0a 16 6b 54 74 35 22 ...
    - mismatch in indices
    - student   index(457) = 999
    - reference index(457) = 458

    - failed on trial 1 of 1000

==> FAILED

Test 4: check index() and length() with random extended ASCII strings
  * length = 10
    - string = hex representation: 75 67 bc dc b1 a3 f9 26 1c 75
    - mismatch in indices
    - student   index(3) = 9
    - reference index(3) = 0

    - failed on trial 45 of 1000

  * length = 100
    - string = hex representation: fd 85 f1 fc 7a 22 25 c9 e9 1e 02 44 4b 84 56 fb 19 da 04 9a ...
    - mismatch in indices
    - student   index(38) = 99
    - reference index(38) = 14

    - failed on trial 11 of 1000

  * length = 1000
    - string = hex representation: 64 ed a9 dd cd b1 3e 6f 81 88 82 ae 05 d5 17 db 33 cd 36 11 ...
    - mismatch in indices
    - student   index(23) = 999
    - reference index(23) = 235

    - failed on trial 1 of 1000

==> FAILED

Test 5: check index() and length() with strings from text files
  * cadabra.txt
    - string = "CADABRA!ABRA"
    - mismatch in indices
    - student   index(1) = 11
    - reference index(1) = 6

  * amendments.txt
    - string = "Article I. Congress shall make no law respecting an establis..."
    - mismatch in indices
    - student   index(0) = 18368
    - reference index(0) = 14383

  * moby1.txt
    - string = "Call me Ishmael. Some years ago- never mind how long precise..."
    - mismatch in indices
    - student   index(0) = 12217
    - reference index(0) = 10396

  * dickens1000.txt
    - string = "It was the best of times, it was the worst of times, it was ..."
    - mismatch in indices
    - student   index(759) = 999
    - reference index(759) = 969

==> FAILED

Test 6: check index() and length() with strings from binary files
  * us.gif
    - string = hex representation: 47 49 46 38 39 61 8e 01 01 01 d5 00 00 94 18 29 06 02 03 84 ...
    - mismatch in indices
    - student   index(3353) = 12399
    - reference index(3353) = 509

  * CS_bricks.jpg
    - string = hex representation: ff d8 ff e1 00 16 45 78 69 66 00 00 4d 4d 00 2a 00 00 00 08 ...
    - mismatch in indices
    - student   index(20674) = 24566
    - reference index(20674) = 17181

  * rand1K.bin
    - string = hex representation: 91 a6 be ff 17 30 3b c2 90 4c dc 6f 14 73 64 27 04 6b 87 8a ...
    - mismatch in indices
    - student   index(683) = 999
    - reference index(683) = 574

==> FAILED

Test 7: check index() and length() with random strings of length 0, 1, and 2
  * length = 0
  * length = 1
  * length = 2
==> passed

Test 8: check that index() throws an exception when argument is out of bounds
  * string of length 10
  * string of length 100
  * string of length 2
  * string of length 1
  * string of length 0
==> passed

Test 9: check that constructor throws an exception when argument is null
    - throws the wrong exception when calling constructor with a null argument
    - throws a java.lang.NullPointerException
    - should throw a java.lang.IllegalArgumentException

==> FAILED

Test 10: check that two CircularSuffixArray objects can be created at the same time
  * cadabra.txt and amendments.txt
    - string = "CADABRA!ABRA"
    - mismatch in indices
    - student   index(1) = 11
    - reference index(1) = 6

    - string = "Article I. Congress shall make no law respecting an establis..."
    - mismatch in indices
    - student   index(0) = 18368
    - reference index(0) = 14383

  * amendments.txt and cadabra.txt
    - string = "Article I. Congress shall make no law respecting an establis..."
    - mismatch in indices
    - student   index(0) = 18368
    - reference index(0) = 14383

    - string = "CADABRA!ABRA"
    - mismatch in indices
    - student   index(1) = 11
    - reference index(1) = 6

  * dickens1000.txt and cadabra.txt
    - string = "It was the best of times, it was the worst of times, it was ..."
    - mismatch in indices
    - student   index(759) = 999
    - reference index(759) = 969

    - string = "CADABRA!ABRA"
    - mismatch in indices
    - student   index(1) = 11
    - reference index(1) = 6

==> FAILED

Test 11: check that CircularSuffixArray is immutable
  * string = "YVKBDNGKBYPNCFMYIZKKKTFJHTMLAR"
  * string = "ABABABABBBAAAAAABBBAAAABAAABBA"
  * string = "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
  * string = hex representation: e8 72 2e de 97 f9 ce fb b6 2d 32 f6 b7 30 e3
==> passed

Test 12: check index() and length() with corner-case strings
  * a.txt
  * nomatch.txt
  * zebra.txt
  * alphanum.txt
==> passed

Test 13: check index() and length() with strings that are nontrivial circular
         that are nontrivial circular suffixes of themselves
  * stars.txt
  * couscous.txt
==> passed

Test 14: check index() and length() with unary strings
  * length 10 string over unary alphabet
  * length 100 string over unary alphabet
  * length 1000 string over unary alphabet
==> passed

Test 15: check index() and length() with random strings
         that are nontrivial circular suffixes of themselves
  * length 2 string over binary alphabet, repeated 2 times
  * length 2 string over binary alphabet, repeated 10 times
  * length 5 string over binary alphabet, repeated 2 times
    - string = "BBBAABBBAA"
    - mismatch in indices
    - student   index(0) = 9
    - reference index(0) = 3

    - failed on trial 2 of 5

  * length 5 string over binary alphabet, repeated 3 times
    - string = "ABAABABAABABAAB"
    - mismatch in indices
    - student   index(3) = 13
    - reference index(3) = 0

    - failed on trial 5 of 5

  * length 5 string over binary alphabet, repeated 5 times
    - string = "BABBBBABBBBABBBBABBBBABBB"
    - mismatch in indices
    - student   index(5) = 24
    - reference index(5) = 0

    - failed on trial 2 of 5

  * length 7 string over uppercase alphabet, repeated 2 times
  * length 7 string over uppercase alphabet, repeated 3 times
    - string = "KJRLFZLKJRLFZLKJRLFZL"
    - mismatch in indices
    - student   index(9) = 20
    - reference index(9) = 3

    - failed on trial 1 of 5

  * length 7 string over uppercase alphabet, repeated 5 times
==> FAILED

Total: 6/15 tests passed!


================================================================
Testing correctness of MoveToFront
*-----------------------------------------------------------
Running 23 total tests.

Test 1a: check main() on text files
  * java MoveToFront - < abra.txt
  * java MoveToFront - < zebra.txt
  * java MoveToFront - < amendments.txt
  * java MoveToFront - < aesop.txt
==> passed

Test 1b: check main() on text files
  * java MoveToFront + < abra.txt.mtf
  * java MoveToFront + < zebra.txt.mtf
  * java MoveToFront + < amendments.txt.mtf
  * java MoveToFront + < aesop.txt.mtf
==> passed

Test 2a: check that main() is consistent with encode() on text files
  * abra.txt
  * zebra.txt
  * amendments.txt
  * aesop.txt
==> passed

Test 2b: check that main() is consistent with decode() on text files
  * abra.txt.mtf
  * zebra.txt.mtf
  * amendments.txt.mtf
  * aesop.txt.mtf
==> passed

Test 3a: check encode() on text files
  * abra.txt
  * zebra.txt
  * amendments.txt
  * aesop.txt
  * stars.txt
  * alphanum.txt
  * a.txt
==> passed

Test 3b: check encode() on binary files
  * us.gif
  * CS_bricks.jpg
  * rand10K.bin
==> passed

Test 3c: check encode() on random inputs
  * 10 random characters from { A } alphabet
  * 10 random characters from { A, B } alphabet
  * 10 random characters from { A, T, C, G } alphabet
  * 10 random characters from uppercase letter alphabet
  * 1000 random characters from { A } alphabet
  * 1000 random characters from { A, B } alphabet
  * 1000 random characters from { A, T, C, G } alphabet
  * 1000 random characters from uppercase letter alphabet
==> passed

Test 3d: check encode() on more random inputs
  * 1000 random characters from ASCII alphabet
  * 1000 random characters from extended ASCII alphabet
  * 1000 random characters from extended ASCII alphabet (excluding 0x00)
  * 1000 random characters from extended ASCII alphabet (excluding 0xFF)
==> passed

Test 4a: check decode() on move-to-front-encoded text files
  * abra.txt.mtf
  * zebra.txt.mtf
  * amendments.txt.mtf
  * aesop.txt.mtf
  * stars.txt.mtf
  * alphanum.txt.mtf
  * a.txt.mtf
==> passed

Test 4b: check decode() on move-to-front encoded binary files
  * us.gif.mtf
  * CS_bricks.jpg.mtf
  * rand10K.bin.mtf
==> passed

Test 4c: check decode() on random inputs
  * 10 random characters from { A } alphabet
  * 10 random characters from { A, B } alphabet
  * 10 random characters from { A, T, C, G } alphabet
  * 10 random characters from uppercase letter alphabet
  * 1000 random characters from { A } alphabet
  * 1000 random characters from { A, B } alphabet
  * 1000 random characters from { A, T, C, G } alphabet
  * 1000 random characters from uppercase letter alphabet
==> passed

Test 4d: check decode() on more random inputs
  * 1000 random characters from ASCII alphabet
  * 1000 random characters from extended ASCII alphabet
  * 1000 random characters from extended ASCII alphabet (excluding 0x00)
  * 1000 random characters from extended ASCII alphabet (excluding 0xFF)
==> passed

Test 4e: check decode() on random inputs
         that were encoded with move-to-front
  * 10 random characters from { A } alphabet
  * 10 random characters from { A, B } alphabet
  * 10 random characters from { A, T, C, G } alphabet
  * 10 random characters from uppercase letter alphabet
  * 1000 random characters from { A } alphabet
  * 1000 random characters from { A, B } alphabet
  * 1000 random characters from { A, T, C, G } alphabet
  * 1000 random characters from uppercase letter alphabet
==> passed

Test 4f: check decode() on more random inputs
         that were encoded with move-to-front
  * 1000 random characters from ASCII alphabet
  * 1000 random characters from extended ASCII alphabet
  * 1000 random characters from extended ASCII alphabet (excluding 0x00)
  * 1000 random characters from extended ASCII alphabet (excluding 0xFF)
==> passed

Test 5a: check whether decode(encode()) = original on text files
  * abra.txt
  * zebra.txt
  * amendments.txt
  * aesop.txt
  * stars.txt
  * alphanum.txt
  * a.txt
==> passed

Test 5b: check whether decode(encode()) = original on binary files
  * us.gif
  * CS_bricks.jpg
  * rand10K.bin
==> passed

Test 5c: check that decode(encode()) = original on random inputs
  * 10 random characters from { A } alphabet
  * 10 random characters from { A, B } alphabet
  * 10 random characters from { A, T, C, G } alphabet
  * 10 random characters from uppercase letter alphabet
  * 100 random characters from { A } alphabet
  * 1000 random characters from { A, B } alphabet
  * 1000 random characters from { A, T, C, G } alphabet
  * 1000 random characters from uppercase letter alphabet
==> passed

Test 5d: check that decode(encode()) = original on random inputs
  * 1000 random characters from ASCII alphabet
  * 1000 random characters from extended ASCII alphabet
  * 1000 random characters from extended ASCII alphabet (excluding 0x00)
  * 1000 random characters from extended ASCII alphabet (excluding 0xFF)
==> passed

Test 6a: check that encode() calls either close() or flush()
  * amendments.txt
  * aesop.txt
==> passed

Test 6b: check that decode() calls either close() or flush()
  * amendments.txt.mtf
  * aesop.txt.mtf
==> passed

Test 7a: check encode() on large files
  * rand100K.bin
  * world192.txt
==> passed

Test 7b: check decode() on large files
  * rand100K.bin.mtf
  * world192.txt.mtf
==> passed

Test 7c: check whether decode(encode()) = original on large files
  * rand100K.bin
  * world192.txt
==> passed


Total: 23/23 tests passed!


================================================================
********************************************************************************
*  TESTING CORRECTNESS (substituting reference CircularSuffixArray)
********************************************************************************

Testing correctness of BurrowsWheeler
*-----------------------------------------------------------
Running 26 total tests.

Test 1a: check main() on text files
  * java BurrowsWheeler - < abra.txt
  * java BurrowsWheeler - < zebra.txt
  * java BurrowsWheeler - < cadabra.txt
  * java BurrowsWheeler - < amendments.txt
==> passed

Test 1b: check main() on text files
  * java BurrowsWheeler + < abra.txt.bwt
  * java BurrowsWheeler + < zebra.txt.bwt
  * java BurrowsWheeler + < cadabra.txt.bwt
    - entry 0 of the two sequences are not equal
    - student   entry = 41
    - reference entry = 43
    - student:   41 42 52 41 43 41 44 41 42 52 41 21
    - reference: 43 41 44 41 42 52 41 21 41 42 52 41

  * java BurrowsWheeler + < amendments.txt.bwt
    - entry 0 of the two sequences are not equal
    - student   entry = 0a
    - reference entry = 41
    - student:   0a 41 20 6e 75 6d 62 65 72 .. 20 64 69 72 65 63 74 3a 0a
    - reference: 41 72 74 69 63 6c 65 20 49 .. 65 72 76 65 6e 65 64 2e 0a

==> FAILED

Test 2a: check that main() is consistent with transform() on text files
  * abra.txt
  * zebra.txt
  * cadabra.txt
  * amendments.txt
==> passed

Test 2b: check that main() is consistent with inverseTransform() on text files
  * abra.txt.bwt
  * zebra.txt.bwt
  * cadabra.txt.bwt
  * amendments.txt.bwt
==> passed

Test 3a: check transform() on text files
  * abra.txt
  * zebra.txt
  * cadabra.txt
  * amendments.txt
==> passed

Test 3b: check transform() on corner-case text files
  * alphanum.txt
  * a.txt
==> passed

Test 3c: check transform() on binary files
  * us.gif
  * CS_bricks.jpg
  * rand10K.bin
==> passed

Test 3d: check transform() on random inputs
  * 10 random characters from binary alphabet
  * 10 random characters from DNA alphabet
  * 10 random characters from uppercase alphabet
  * 1000 random characters from binary alphabet
  * 1000 random characters from DNA alphabet
  * 1000 random characters from uppercase alphabet
==> passed

Test 3e: check transform() on more random inputs
  * 1000 random characters from ASCII alphabet
  * 1000 random characters from extended ASCII alphabet
  * 1000 random characters from extended ASCII alphabet (excluding 0x00)
  * 1000 random characters from extended ASCII alphabet (excluding 0xFF)
==> passed

Test 3f: check tranform() on random inputs that are circular
         shifts of themselves
  * 5 random strings from unary alphabet
  * 5 random strings from binary alphabet
  * 5 random strings from DNA alphabet
  * 5 random strings from uppercase alphabet
==> passed

Test 4a: check inverseTransform() on text files
  * abra.txt.bwt
  * zebra.txt.bwt
  * cadabra.txt.bwt
    - entry 0 of the two sequences are not equal
    - student   entry = 41
    - reference entry = 43
    - student:   41 42 52 41 43 41 44 41 42 52 41 21
    - reference: 43 41 44 41 42 52 41 21 41 42 52 41

  * amendments.txt.bwt
    - entry 0 of the two sequences are not equal
    - student   entry = 0a
    - reference entry = 41
    - student:   0a 41 20 6e 75 6d 62 65 72 .. 20 64 69 72 65 63 74 3a 0a
    - reference: 41 72 74 69 63 6c 65 20 49 .. 65 72 76 65 6e 65 64 2e 0a

==> FAILED

Test 4b: check inverseTransform() on corner-case text files
  * alphanum.txt.bwt
    - entry 0 of the two sequences are not equal
    - student   entry = 31
    - reference entry = 61
    - student:   31 32 33 34 35 36 37 38 39 .. 73 74 75 76 77 78 79 7a 30
    - reference: 61 62 63 64 65 66 67 68 69 .. 31 32 33 34 35 36 37 38 39

  * a.txt.bwt
  * stars.txt.bwt
    - student   length = 1
    - reference length = 13
    - student:   2a
    - reference: 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a

  * couscous.txt.bwt
    - student   length = 4
    - reference length = 8
    - entry 0 of the two sequences are not equal
    - student   entry = 6f
    - reference entry = 63
    - student:   6f 75 73 63
    - reference: 63 6f 75 73 63 6f 75 73

==> FAILED

Test 4c: check inverseTransform() on binary files
  * us.gif.bwt
    - entry 0 of the two sequences are not equal
    - student   entry = 00
    - reference entry = 47
    - student:   00 00 00 8e 01 01 01 00 06 .. d6 ff ff ff f7 f7 f7 2c 00
    - reference: 47 49 46 38 39 61 8e 01 01 .. 7f 03 1e 38 cc 41 00 00 3b

  * CS_bricks.jpg.bwt
    - entry 0 of the two sequences are not equal
    - student   entry = 00
    - reference entry = ff
    - student:   00 00 00 00 00 00 00 00 00 .. 00 18 01 01 01 01 01 01 00
    - reference: ff d8 ff e1 00 16 45 78 69 .. 46 8d 01 a3 46 8d 07 ff d9

  * rand10K.bin.bwt
    - entry 0 of the two sequences are not equal
    - student   entry = 05
    - reference entry = 1a
    - student:   05 83 92 47 93 14 38 5c 28 .. 51 51 8f a9 97 f2 bb c6 00
    - reference: 1a de 9d f2 73 73 0c 05 e1 .. 46 04 ae 11 4f d4 bc 2d b4

==> FAILED

Test 4d: check inverseTransform() of transform() on random inputs
  * 10 random characters from unary alphabet
    - student   length = 1
    - reference length = 10
    - student:   41
    - reference: 41 41 41 41 41 41 41 41 41 41

    - failed on trial 1 of 2
    - input = 'AAAAAAAAAA'

  * 10 random characters from binary alphabet
    - entry 4 of the two sequences are not equal
    - student   entry = 41
    - reference entry = 42
    - student:   41 42 42 42 41 42 42 42 42 41
    - reference: 41 42 42 42 42 41 41 42 42 42

    - failed on trial 1 of 100
    - input = 'ABBBBAABBB'

  * 10 random characters from DNA alphabet
    - entry 0 of the two sequences are not equal
    - student   entry = 41
    - reference entry = 43
    - student:   41 41 41 41 54 43 47 41 54 41
    - reference: 43 47 41 54 41 41 41 41 41 54

    - failed on trial 1 of 100
    - input = 'CGATAAAAAT'

  * 10 random characters from uppercase alphabet
    - entry 0 of the two sequences are not equal
    - student   entry = 5a
    - reference entry = 47
    - student:   5a 4f 4c 48 55 49 53 52 4d 47
    - reference: 47 5a 4f 4c 48 55 49 53 52 4d

    - failed on trial 1 of 100
    - input = 'GZOLHUISRM'

  * 100 random characters from unary alphabet
    - student   length = 1
    - reference length = 100
    - student:   41
    - reference: 41 41 41 41 41 41 41 41 41 .. 41 41 41 41 41 41 41 41 41

    - failed on trial 1 of 2

  * 1000 random characters from binary alphabet
    - entry 4 of the two sequences are not equal
    - student   entry = 41
    - reference entry = 42
    - student:   41 41 41 41 41 41 41 41 41 .. 42 41 41 41 41 42 42 42 41
    - reference: 41 41 41 41 42 42 41 41 42 .. 41 41 42 41 42 41 41 41 42

    - failed on trial 1 of 100

  * 1000 random characters from DNA alphabet
    - entry 0 of the two sequences are not equal
    - student   entry = 41
    - reference entry = 47
    - student:   41 41 41 41 43 43 41 54 41 .. 41 41 54 47 41 41 47 43 41
    - reference: 47 43 41 54 41 47 43 41 41 .. 47 43 41 41 54 54 43 43 43

    - failed on trial 1 of 100

  * 1000 random characters from uppercase alphabet
    - entry 0 of the two sequences are not equal
    - student   entry = 42
    - reference entry = 5a
    - student:   42 4a 53 41 45 44 42 52 49 .. 43 44 57 4c 4d 45 59 5a 41
    - reference: 5a 57 58 4e 4a 46 46 4a 47 .. 4b 55 4c 58 49 47 50 41 44

    - failed on trial 1 of 100

==> FAILED

Test 4e: check inverseTransform() of transform() on more random inputs
  * 1000 random characters from ASCII alphabet
    - entry 0 of the two sequences are not equal
    - student   entry = 02
    - reference entry = 75
    - student:   02 4b 70 4c 7c 4b 67 42 00 .. 5a 50 28 07 2a 5b 12 40 00
    - reference: 75 06 33 2e 75 5e 27 5f 06 .. 2e 7b 44 38 6a 5a 5e 39 2e

    - failed on trial 1 of 100

  * 1000 random characters from extended ASCII alphabet
    - entry 0 of the two sequences are not equal
    - student   entry = 41
    - reference entry = c3
    - student:   41 3a 3b 1a 81 cb 9b ac 1e .. 0a 36 7b 9c 2a f4 11 91 00
    - reference: c3 21 cc 4c 90 c6 bd 33 20 .. 11 cf 1e 6c ed 15 ca f3 c5

    - failed on trial 1 of 100

  * 1000 random characters from extended ASCII alphabet (excluding 0x00)
    - entry 0 of the two sequences are not equal
    - student   entry = 60
    - reference entry = f1
    - student:   60 7f a8 18 21 27 e6 90 54 .. b4 cc d8 3c 55 b4 66 a9 00
    - reference: f1 9a d4 27 38 bc af 30 cb .. 63 d2 6b e1 90 1d 07 3a fe

    - failed on trial 1 of 100

  * 1000 random characters from extended ASCII alphabet (excluding 0xFF)
    - entry 0 of the two sequences are not equal
    - student   entry = 94
    - reference entry = 6b
    - student:   94 e6 86 93 15 fb 8b ab 20 .. c9 d7 f2 7a 05 1b f5 cc 00
    - reference: 6b 36 c0 b3 80 89 f2 d1 fb .. 74 4f c4 2a bf 3d 36 b5 73

    - failed on trial 1 of 100

==> FAILED

Test 5a: check that inverseTransform(transform()) = original on text files
  * abra.txt
  * zebra.txt
  * cadabra.txt
    - entry 0 of the two sequences are not equal
    - student   entry = 41
    - reference entry = 43
    - student:   41 42 52 41 43 41 44 41 42 52 41 21
    - reference: 43 41 44 41 42 52 41 21 41 42 52 41

  * amendments.txt
    - entry 0 of the two sequences are not equal
    - student   entry = 0a
    - reference entry = 41
    - student:   0a 41 20 6e 75 6d 62 65 72 .. 20 64 69 72 65 63 74 3a 0a
    - reference: 41 72 74 69 63 6c 65 20 49 .. 65 72 76 65 6e 65 64 2e 0a

==> FAILED

Test 5b: check that inverseTransform(transform()) = original on corner-case text files
  * alphanum.txt
    - entry 0 of the two sequences are not equal
    - student   entry = 31
    - reference entry = 61
    - student:   31 32 33 34 35 36 37 38 39 .. 73 74 75 76 77 78 79 7a 30
    - reference: 61 62 63 64 65 66 67 68 69 .. 31 32 33 34 35 36 37 38 39

  * a.txt
  * stars.txt
    - student   length = 1
    - reference length = 13
    - student:   2a
    - reference: 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a

  * couscous.txt
    - student   length = 4
    - reference length = 8
    - entry 0 of the two sequences are not equal
    - student   entry = 6f
    - reference entry = 63
    - student:   6f 75 73 63
    - reference: 63 6f 75 73 63 6f 75 73

==> FAILED

Test 5c: check that inverseTransform(transform()) = original on binary files
  * us.gif
    - entry 0 of the two sequences are not equal
    - student   entry = 00
    - reference entry = 47
    - student:   00 00 00 8e 01 01 01 00 06 .. d6 ff ff ff f7 f7 f7 2c 00
    - reference: 47 49 46 38 39 61 8e 01 01 .. 7f 03 1e 38 cc 41 00 00 3b

  * CS_bricks.jpg
    - entry 0 of the two sequences are not equal
    - student   entry = 00
    - reference entry = ff
    - student:   00 00 00 00 00 00 00 00 00 .. 00 18 01 01 01 01 01 01 00
    - reference: ff d8 ff e1 00 16 45 78 69 .. 46 8d 01 a3 46 8d 07 ff d9

  * rand10K.bin
    - entry 0 of the two sequences are not equal
    - student   entry = 05
    - reference entry = 1a
    - student:   05 83 92 47 93 14 38 5c 28 .. 51 51 8f a9 97 f2 bb c6 00
    - reference: 1a de 9d f2 73 73 0c 05 e1 .. 46 04 ae 11 4f d4 bc 2d b4

==> FAILED

Test 5d: check that inverseTransform(tranform()) = original on random inputs
  * 10 random characters from binary alphabet
    - entry 0 of the two sequences are not equal
    - student   entry = 41
    - reference entry = 42
    - student:   41 42 41 42 42 41 41 42 42 41
    - reference: 42 42 41 41 42 41 42 42 41 41

    - failed on trial 1 of 100
    - input = 'BBAABABBAA'

  * 10 random characters from DNA alphabet
    - entry 3 of the two sequences are not equal
    - student   entry = 47
    - reference entry = 41
    - student:   54 54 43 47 43 47 54 54 43 41
    - reference: 54 54 43 41 54 54 43 47 43 47

    - failed on trial 1 of 100
    - input = 'TTCATTCGCG'

  * 10 random characters from uppercase alphabet
    - entry 0 of the two sequences are not equal
    - student   entry = 57
    - reference entry = 50
    - student:   57 59 52 50 43 4e 44 57 51 42
    - reference: 50 43 4e 44 57 51 42 57 59 52

    - failed on trial 1 of 100
    - input = 'PCNDWQBWYR'

  * 1000 random characters from binary alphabet
    - entry 0 of the two sequences are not equal
    - student   entry = 41
    - reference entry = 42
    - student:   41 41 41 41 41 41 41 41 42 .. 42 41 42 41 42 41 41 42 41
    - reference: 42 41 41 42 41 41 42 42 41 .. 42 41 41 42 41 41 41 42 42

    - failed on trial 1 of 100

  * 1000 random characters from DNA alphabet
    - entry 0 of the two sequences are not equal
    - student   entry = 41
    - reference entry = 47
    - student:   41 41 41 43 54 47 41 54 43 .. 54 47 54 43 54 54 41 43 41
    - reference: 47 43 43 54 47 54 41 43 43 .. 43 41 54 41 41 54 47 43 43

    - failed on trial 1 of 100

  * 1000 random characters from uppercase alphabet
    - entry 0 of the two sequences are not equal
    - student   entry = 42
    - reference entry = 46
    - student:   42 4e 41 4a 48 54 4c 58 5a .. 4b 4c 49 59 4d 58 47 5a 41
    - reference: 46 54 47 4c 47 59 49 43 42 .. 59 54 58 42 53 50 58 53 44

    - failed on trial 1 of 100

==> FAILED

Test 5e: check that inverseTransform(tranform()) = original on random inputs
  * 1000 random characters from ASCII alphabet
    - entry 0 of the two sequences are not equal
    - student   entry = 03
    - reference entry = 49
    - student:   03 71 42 24 4b 0d 79 5c 5e .. 75 2f 33 72 1d 1b 30 14 00
    - reference: 49 39 33 7e 56 43 5f 27 22 .. 4e 39 3a 7f 53 1f 68 43 21

    - failed on trial 1 of 100

  * 1000 random characters from extended ASCII alphabet
    - entry 0 of the two sequences are not equal
    - student   entry = 23
    - reference entry = 51
    - student:   23 ba 2e 05 69 05 de 2d d6 .. a7 c6 92 29 c2 f1 07 9c 00
    - reference: 51 28 7d a6 52 e3 b0 04 24 .. 20 89 34 3a d3 de d6 1d a7

    - failed on trial 1 of 100

  * 1000 random characters from extended ASCII alphabet (excluding 0x00)
    - entry 0 of the two sequences are not equal
    - student   entry = 7b
    - reference entry = 1b
    - student:   7b d8 1d a9 2d 6f 37 1a 55 .. 02 64 5d 8f 41 da f0 7d 00
    - reference: 1b 52 23 ed 03 14 53 99 4c .. 10 a3 45 b0 db 7e 29 72 6b

    - failed on trial 1 of 100

  * 1000 random characters from extended ASCII alphabet (excluding 0xFF)
    - entry 0 of the two sequences are not equal
    - student   entry = 1c
    - reference entry = 2f
    - student:   1c c2 65 0e a6 72 00 ec 56 .. e2 0c 12 03 6a 8b 14 61 00
    - reference: 2f 0b 84 35 93 90 8d e2 95 .. a7 ab 38 02 bc d5 65 c6 a1

    - failed on trial 1 of 100

==> FAILED

Test 5f: check that inverseTransform(tranform()) = original
         on random inputs that are circular shifts of themselves
  * random strings from unary alphabet
    - student   length = 1
    - reference length = 20
    - student:   41
    - reference: 41 41 41 41 41 41 41 41 41 41 41 41 41 41 41 41 41 41 41 41

    - failed on trial 1 of 2
    - input = 'AAAAAAAAAAAAAAAAAAAA'

  * random strings from binary alphabet
    - student   length = 5
    - reference length = 10
    - entry 0 of the two sequences are not equal
    - student   entry = 41
    - reference entry = 42
    - student:   41 42 41 42 41
    - reference: 42 41 41 42 41 42 41 41 42 41

    - failed on trial 1 of 100
    - input = 'BAABABAABA'

  * random strings from DNA alphabet
    - student   length = 5
    - reference length = 25
    - entry 0 of the two sequences are not equal
    - student   entry = 43
    - reference entry = 47
    - student:   43 47 54 47 41
    - reference: 47 41 43 47 54 47 41 43 47 .. 41 43 47 54 47 41 43 47 54

    - failed on trial 1 of 100
    - input = 'GACGTGACGTGACGTGACGTGACGT'

  * random strings from uppercase alphabet
    - student   length = 5
    - reference length = 20
    - entry 0 of the two sequences are not equal
    - student   entry = 4d
    - reference entry = 59
    - student:   4d 58 4e 59 42
    - reference: 59 42 4d 58 4e 59 42 4d 58 4e 59 42 4d 58 4e 59 42 4d 58 4e

    - failed on trial 1 of 100
    - input = 'YBMXNYBMXNYBMXNYBMXN'

==> FAILED

Test 6a: check that transform() calls either close() or flush()
  * amendments.txt
  * aesop.txt
==> passed

Test 6b: check that inverseTransform() calls either close() or flush()
  * amendments.txt.bwt
    - entry 0 of the two sequences are not equal
    - student   entry = 0a
    - reference entry = 41
    - student:   0a 41 20 6e 75 6d 62 65 72 .. 20 64 69 72 65 63 74 3a 0a
    - reference: 41 72 74 69 63 6c 65 20 49 .. 65 72 76 65 6e 65 64 2e 0a

  * aesop.txt.bwt
    - entry 0 of the two sequences are not equal
    - student   entry = 0a
    - reference entry = 41
    - student:   0a 0a 4a 75 70 69 74 65 72 .. 6c 69 74 79 2e 20 20 20 0a
    - reference: 41 65 73 6f 70 27 73 20 46 .. 72 20 73 75 6e 73 3f 22 0a

==> FAILED

Test 7a: check transform() on large files
  * rand100K.bin
  * world192.txt
==> passed

Test 7b: check inverseTransform() on large files
  * rand100K.bin.bwt
    - entry 0 of the two sequences are not equal
    - student   entry = 00
    - reference entry = 73
    - student:   00 5b de b1 32 cf 25 ae 73 .. ea 5a 6e f6 26 42 0f f1 00
    - reference: 73 fe be 6c 9d a3 82 eb 5e .. f5 60 4f 60 99 82 d5 72 38

  * world192.txt.bwt


WARNING: the time limit of 180 seconds was exceeded, so not all tests could be completed.



Total: 0/26 tests passed: Could not complete tests, which results in a reported score of 0.
================================================================
********************************************************************************
*  MEMORY
********************************************************************************

Analyzing memory of CircularSuffixArray
*-----------------------------------------------------------
Running 10 total tests.

Memory usage of a CircularSuffixArray for a random string of length n.
Maximum allowed memory is 64n + 128.

                 n        bytes
-------------------------------
=> passed       16          800
=> passed       32         1472
=> passed       64         2816
=> passed      128         5504
=> passed      256        10880
=> passed      512        21632
=> passed     1024        43136
=> passed     2048        86144
=> passed     4096       172160
=> passed     8192       344192
==> 10/10 tests passed

Total: 10/10 tests passed!

Estimated student memory (bytes) = 42.00 n + 128.00   (R^2 = 1.000)
================================================================



********************************************************************************
*  TIMING
********************************************************************************

Timing CircularSuffixArray
*-----------------------------------------------------------
Running 26 total tests.

Tests  1-13: time to create a circular suffix array for the first
             n character of dickens.txt and call index(i) for each i

            [ max allowed time = 10 seconds and <= 12x reference ]

                 n    student  reference      ratio
---------------------------------------------------
=> passed     1000       0.01       0.00      18.86
=> passed     2000       0.00       0.00       4.85
=> passed     4000       0.01       0.00       4.13
=> passed     8000       0.01       0.00       2.31
=> passed    16000       0.02       0.01       2.58
=> passed    32000       0.04       0.01       4.62
=> passed    64000       0.10       0.01      11.64
=> passed   128000       0.17       0.02      10.38
=> passed   256000       0.20       0.02       8.66
=> passed   512000       0.36       0.05       7.17
=> passed  1024000       0.79       0.11       7.27
=> passed  2048000       1.89       0.28       6.83
=> passed  4096000       4.39       0.73       5.98

Estimated running time (using last 6 measurements)
    = 1.26e-06 * n^0.98  (R^2 = 0.97)


Tests 14-26: time to create circular suffix array for n random ASCII characters
            and call index(i) for each i

            [ max allowed time = 10 seconds and <= 20x reference ]

                 n    student  reference      ratio
---------------------------------------------------
=> passed     1000       0.00       0.00       4.91
=> passed     2000       0.00       0.00       2.14
=> passed     4000       0.00       0.00       2.04
=> passed     8000       0.00       0.00       3.25
=> passed    16000       0.01       0.00       4.97
=> passed    32000       0.01       0.00       6.60
=> passed    64000       0.03       0.00       6.86
=> passed   128000       0.06       0.01       7.42
=> passed   256000       0.13       0.03       4.44
=> passed   512000       0.29       0.04       8.22
=> passed  1024000       0.64       0.06      11.23
=> passed  2048000       1.52       0.14      10.98
=> passed  4096000       3.66       0.32      11.54

Estimated running time (using last 6 measurements)
    = 4.92e-08 * n^1.19  (R^2 = 1.00)


Total: 26/26 tests passed!


================================================================



********************************************************************************
*  TIMING
********************************************************************************

Timing MoveToFront
*-----------------------------------------------------------
Running 38 total tests.

Test 1: count calls to methods in BinaryStdOut from encode()
  * abra.txt
  * amendments.txt
==> passed

Test 2: count calls to methods in BinaryStdOut from decode()
  * abra.txt.mtf
  * amendments.txt.mtf
==> passed

Tests  3-12: Timing encode() with first n character of dickens.txt
             [ max allowed time = 2 seconds and <= 4x reference ]

                 n    student  reference      ratio
---------------------------------------------------
=> passed     1000       0.01       0.00       2.67
=> passed     2000       0.01       0.00       4.13
=> passed     4000       0.02       0.00       4.30
=> passed     8000       0.04       0.01       4.26
=> passed    16000       0.08       0.02       4.45
=> FAILED    32000       0.17       0.04       4.44
=> FAILED    64000       0.33       0.07       4.56
=> FAILED   128000       0.67       0.14       4.61
=> FAILED   256000       1.34       0.29       4.64

Student running time for encode() is possibly R n.

Estimated running time (using last 6 measurements)
     = 5.34e-06 * n^1.00  (R^2 = 1.00)


Tests  13-20: Timing encode() with first n character of abab.txt
             [ max allowed time = 2 seconds and <= 4x reference ]

                 n    student  reference      ratio
---------------------------------------------------
=> passed     1000       0.01       0.00       5.31
=> passed     2000       0.01       0.00       5.39
=> passed     4000       0.02       0.00       5.40
=> passed     8000       0.04       0.01       5.42
=> passed    16000       0.08       0.02       5.39
=> FAILED    32000       0.16       0.03       5.41
=> FAILED    64000       0.32       0.06       5.40
=> FAILED   128000       0.65       0.12       5.40
=> FAILED   256000       1.30       0.24       5.38

Student running time for encode() is possibly R n.

Estimated running time (using last 6 measurements)
     = 5.06e-06 * n^1.00  (R^2 = 1.00)


Tests 21-29: Timing decode() with first n character of dickens.txt
             [ max allowed time = 2 seconds and <= 4x reference ]

                 n    student  reference      ratio
---------------------------------------------------
=> passed     1000       0.00       0.00       0.93
=> passed     2000       0.00       0.00       0.93
=> passed     4000       0.00       0.00       0.96
=> passed     8000       0.01       0.01       0.95
=> passed    16000       0.02       0.02       0.95
=> passed    32000       0.03       0.03       0.96
=> passed    64000       0.06       0.06       0.96
=> passed   128000       0.12       0.13       0.96
=> passed   256000       0.24       0.25       0.96

Estimated running time (using last 6 measurements)
     = 1.15e-06 * n^0.98  (R^2 = 1.00)


Tests 30-38: Timing decode() with first n character of abab.txt
             [ max allowed time = 2 seconds and <= 4x reference ]

                 n    student  reference      ratio
---------------------------------------------------
=> passed     1000       0.00       0.00       0.98
=> passed     2000       0.00       0.00       0.94
=> passed     4000       0.00       0.00       0.95
=> passed     8000       0.01       0.01       0.95
=> passed    16000       0.01       0.01       0.94
=> passed    32000       0.03       0.03       0.95
=> passed    64000       0.06       0.06       0.95
=> passed   128000       0.11       0.12       0.95
=> passed   256000       0.23       0.24       0.95

Estimated running time (using last 6 measurements)
     = 8.86e-07 * n^1.00  (R^2 = 1.00)


Total: 30/38 tests passed!


================================================================



********************************************************************************
*  TIMING (substituting reference CircularSuffixArray)
********************************************************************************

Timing BurrowsWheeler
*-----------------------------------------------------------
Running 95 total tests.

Test 1: count calls to methods in CircularSuffixArray from transform()
  * abra.txt
  * amendments.txt
==> passed

Test 2: count calls to methods in CircularSuffixArray from inverseTransform()
  * abra.txt.bwt
  * amendments.txt.bwt
==> passed

Test 3: count calls to methods in BinaryStdOut from transform()
  * abra.txt
  * amendments.txt
==> passed

Test 4: count calls to methods in BinaryStdOut from inverseTransform()
  * abra.txt.bwt
  * amendments.txt.bwt
==> passed

Tests  5-17: timing transform() with first n character of dickens.txt
             [ max allowed time = 2 seconds and <= 8x reference ]

                 n    student  reference      ratio
---------------------------------------------------
=> passed     1000       0.00       0.00       0.11
=> passed     2000       0.00       0.00       0.60
=> passed     4000       0.00       0.00       0.70
=> passed     8000       0.00       0.00       0.91
=> passed    16000       0.00       0.01       0.61
=> passed    32000       0.01       0.01       0.77
=> passed    64000       0.02       0.02       0.93
=> passed   128000       0.02       0.02       1.03
=> passed   256000       0.04       0.04       1.02
=> passed   512000       0.08       0.08       1.06
=> passed  1024000       0.18       0.16       1.12
=> passed  2048000       0.43       0.39       1.10
=> passed  4096000       0.88       0.89       1.00

Estimated running time as a function of n (using last 6 measurements)
    = 3.09e-08 * n^1.13  (R^2 = 1.00)


Tests 18-30: timing transform() with first n character of random.bin
             [ max allowed time = 2 seconds and <= 8x reference ]

                 n    student  reference      ratio
---------------------------------------------------
=> passed     1000       0.00       0.00       0.95
=> passed     2000       0.00       0.00       0.97
=> passed     4000       0.00       0.00       0.82
=> passed     8000       0.00       0.00       0.90
=> passed    16000       0.00       0.00       1.57
=> passed    32000       0.01       0.01       0.97
=> passed    64000       0.01       0.01       0.94
=> passed   128000       0.02       0.02       1.00
=> passed   256000       0.04       0.04       1.05
=> passed   512000       0.09       0.09       1.00
=> passed  1024000       0.19       0.19       1.05
=> passed  2048000       0.42       0.44       0.97
=> passed  4096000       1.11       1.01       1.10

Estimated running time as a function of n (using last 6 measurements)
    = 3.02e-08 * n^1.14  (R^2 = 1.00)


Tests 31-43: timing transform() with first n character of abab.txt
             [ max allowed time = 2 seconds and <= 8x reference ]

                 n    student  reference      ratio
---------------------------------------------------
=> passed     1000       0.00       0.00       0.91
=> passed     2000       0.00       0.00       0.82
=> passed     4000       0.00       0.00       0.97
=> passed     8000       0.00       0.00       0.90
=> passed    16000       0.00       0.00       0.95
=> passed    32000       0.00       0.00       0.58
=> passed    64000       0.00       0.00       0.89
=> passed   128000       0.00       0.00       0.89
=> passed   256000       0.01       0.01       1.47
=> passed   512000       0.01       0.02       0.96
=> passed  1024000       0.02       0.03       0.84
=> passed  2048000       0.05       0.05       0.89
=> passed  4096000       0.10       0.11       0.88

Estimated running time as a function of n (using last 6 measurements)
    = 7.91e-08 * n^0.92  (R^2 = 0.98)


Tests 44-56: timing inverseTransform() with first n character of dickens.txt
             [ max allowed time = 2 seconds and <= 8x reference ]

                 n    student  reference      ratio
---------------------------------------------------
=> passed     1000       0.00       0.00       6.53
=> passed     2000       0.00       0.00      11.96
=> passed     4000       0.01       0.00      22.07
=> passed     8000       0.05       0.00      44.71
=> passed    16000       0.07       0.00      28.90
=> FAILED    32000       0.29       0.00     194.51
=> FAILED    64000       1.27       0.00     474.59
=> FAILED   128000       5.85       0.00    1519.54
=> FAILED   256000
=> FAILED   512000
=> FAILED  1024000
=> FAILED  2048000
=> FAILED  4096000

==> FAILED.   inverseTransform() is possibly n^2 or worse.
Estimated running time as a function of n (using last 6 measurements)
    = 9.70e-09 * n^1.69  (R^2 = 0.97)


Tests 57-69: timing inverseTransform() with first n character of random.bin
             [ max allowed time = 2 seconds and <= 8x reference ]

                 n    student  reference      ratio
---------------------------------------------------
=> passed     1024       0.00       0.00       9.53
=> passed     2048       0.00       0.00      35.38
=> passed     4096       0.01       0.00      62.23
=> passed     8192       0.02       0.00     120.17
=> passed    16384       0.09       0.00     259.05
=> FAILED    32768       0.37       0.00     488.72
=> FAILED    65536       1.46       0.00     795.11
=> FAILED   131072       5.86       0.00    1395.28
=> FAILED   262144
=> FAILED   524288
=> FAILED  1048576
=> FAILED  2097152
=> FAILED  4194304

==> FAILED.   inverseTransform() is possibly n^2 or worse.
Estimated running time as a function of n (using last 6 measurements)
    = 3.87e-10 * n^1.99  (R^2 = 1.00)


Tests 70-82: timing inverseTransform() with first n character of abab.txt
             [ max allowed time = 2 seconds and <= 8x reference ]

                 n    student  reference      ratio
---------------------------------------------------
=> passed     1000       0.00       0.00      12.54
=> passed     2000       0.00       0.00      23.68
=> passed     4000       0.01       0.00      59.84
=> passed     8000       0.02       0.00     119.80
=> passed    16000       0.08       0.00     240.94
=> FAILED    32000       0.33       0.00     468.67
=> FAILED    64000       1.33       0.00     981.74
=> FAILED   128000       5.33       0.00    1979.24
=> FAILED   256000
=> FAILED   512000
=> FAILED  1024000
=> FAILED  2048000
=> FAILED  4096000

==> FAILED.   inverseTransform() is possibly n^2 or worse.
Estimated running time as a function of n (using last 6 measurements)
    = 3.81e-10 * n^1.99  (R^2 = 1.00)


Tests 83-95: timing inverseTransform() with first n character of cyclic.bin
             [ max allowed time = 2 seconds and <= 8x reference ]

                 n    student  reference      ratio
---------------------------------------------------
=> passed     1024       0.00       0.00      12.72
=> passed     2048       0.00       0.00      24.01
=> passed     4096       0.00       0.00      50.30
=> passed     8192       0.02       0.00      57.64
=> passed    16384       0.07       0.00     106.62
=> FAILED    32768       0.26       0.00     207.58
=> FAILED    65536       1.05       0.00     390.90
=> FAILED   131072       4.20       0.01     662.68
=> FAILED   262144
=> FAILED   524288
=> FAILED  1048576
=> FAILED  2097152
=> FAILED  4194304

==> FAILED.   inverseTransform() is possibly n^2 or worse.
Estimated running time as a function of n (using last 6 measurements)
    = 3.07e-10 * n^1.98  (R^2 = 1.00)


Total: 59/95 tests passed!


================================================================